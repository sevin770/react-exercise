
state를 변경하고 싶으면?

let [글제목, 글제목변경] = useState(['여자코트추천', '남자코트추천','아동코트추천']);
  <button onClick={()=>{ 글제목변경(['예쁜코트추천', '남자코트추천','아동코트추천']);}}>글수정</button>
: 이렇게쓰면 되지만 확장성이 떨어진다.

  글제목[0] = '예쁜코트추천';
  글제목변경(글제목);
: 이렇게 써주면 된다. 하지만 이렇게되면 원본이 변형됨. 원본은 남겨두는 편이 좋다. 

- copy를 해서 넣어준다. 
let copy = [...글제목];
copy[0] = '예쁜코트추천';
글제목변경(copy); 

* [...글제목] 왜 이렇게 넣어줘야 하나? 그냥 넣으면 안 되는 이유?
기존 state == 신규state 이기 때문에 작동이 안 된다.

let copy = 글제목; // 1. 배열 저장시 copy에 넣어지는게 아님. copy는 ram저장소에 있다고 가르키고 있을 뿐.
copy[0] = '예쁜코트추천'; // ram저장소에 copy[0]을 바꿔주긴 했지만 실제로 copy가 변경된 건 아님.  
글제목변경(copy); //그래서 처음 copy와 변경한copy가 같다고 판단되고 작동 안됨

let arr = [...숫자] ...는 괄호 벗긴담에 다시 array로 만들어주세요~라는 뜻. 그러면 화살표도 달라져서 새로운 스테이트가 생성된다.
array/object면 독립적 copy본을 만들어서 수정해야 함.


정리)

◆ state변경함수 특징
- 기존 state == 신규state 의 경우 변경 안해줌. 그냥 에너지 절약을 위해 그렇게 동작함.

◆ array, object 특징 

let arr = [1,2,3] 

ram 안에 배열들이 저장된다. arr변수는 그 자료가 어디에 있는지에 대한 화살표일 뿐.
자바스크립트에서 배열,오브젝트를 저장할 땐 그렇게 된다. 변수에 넣어지는 게 아님.

그래서
let data1 = [1,2,3];
let data2 = data1; 

하면 data1과 data2는 같은 자료를 가르키게 되는 화살표가 됨. 
data1을 변경하면 data2도 자동으로 변경됨.
javascript reference data type

->
array/object면 독립적 copy본을 만들어서 수정해야 함.

